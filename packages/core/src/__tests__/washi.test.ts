import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { Washi } from '../Washi';
import { Comment, NewComment, WashiAdapter, WashiMode } from '../types';

// Mock adapter for testing
class MockAdapter implements WashiAdapter {
  private comments: Map<string, Comment> = new Map();

  async save(comment: Comment): Promise<void> {
    this.comments.set(comment.id, comment);
  }

  async load(): Promise<Comment[]> {
    return Array.from(this.comments.values());
  }

  async update(id: string, updates: Partial<Comment>): Promise<void> {
    const comment = this.comments.get(id);
    if (comment) {
      this.comments.set(id, { ...comment, ...updates });
    }
  }

  async delete(id: string): Promise<void> {
    this.comments.delete(id);
  }

  addComment(comment: Comment): void {
    this.comments.set(comment.id, comment);
  }
}

// Helper to create a mock iframe
function createMockIframe(): HTMLIFrameElement {
  const container = document.createElement('div');
  container.style.position = 'relative';
  document.body.appendChild(container);

  const iframe = document.createElement('iframe');
  container.appendChild(iframe);

  const iframeDoc = iframe.contentDocument;
  if (iframeDoc) {
    iframeDoc.open();
    iframeDoc.write('<!DOCTYPE html><html><body></body></html>');
    iframeDoc.close();
  }

  return iframe;
}

// For pre-seeding the MockAdapter (requires full Comment)
function createTestComment(overrides: Partial<Comment> = {}): Comment {
  return {
    id: `comment-${Date.now()}-${Math.random()}`,
    x: 50,
    y: 50,
    text: 'Test comment',
    createdAt: Date.now(),
    ...overrides,
  };
}

// For calling washi.addComment() (NewComment â€” id/createdAt generated by library)
function createNewComment(overrides: Partial<NewComment> = {}): NewComment {
  return {
    x: 50,
    y: 50,
    text: 'Test comment',
    ...overrides,
  };
}

describe('Washi', () => {
  let adapter: MockAdapter;
  let washi: Washi;
  let iframe: HTMLIFrameElement;

  beforeEach(() => {
    adapter = new MockAdapter();
    washi = new Washi(adapter);
    iframe = createMockIframe();
  });

  afterEach(() => {
    washi.unmount();
    iframe.parentElement?.remove();
  });

  describe('constructor', () => {
    it('creates instance with adapter', () => {
      expect(new Washi(adapter)).toBeInstanceOf(Washi);
    });
  });

  describe('mount()', () => {
    it('mounts to iframe and creates overlay', async () => {
      await washi.mount(iframe);
      expect(document.querySelector('.washi-overlay')).toBeTruthy();
    });

    it('throws if already mounted', async () => {
      await washi.mount(iframe);
      await expect(washi.mount(iframe)).rejects.toThrow('already mounted');
    });

    it('throws if iframe not in DOM', async () => {
      const detached = document.createElement('iframe');
      await expect(washi.mount(detached)).rejects.toThrow('DOM');
    });

    it('loads existing comments', async () => {
      adapter.addComment(createTestComment({ id: 'existing' }));
      await washi.mount(iframe);
      expect(washi.getComments()).toHaveLength(1);
    });
  });

  describe('unmount()', () => {
    it('removes overlay', async () => {
      await washi.mount(iframe);
      washi.unmount();
      expect(document.querySelector('.washi-overlay')).toBeFalsy();
    });

    it('is safe to call multiple times', async () => {
      await washi.mount(iframe);
      washi.unmount();
      expect(() => washi.unmount()).not.toThrow();
    });
  });

  describe('setMode()', () => {
    it('changes overlay pointer-events', async () => {
      await washi.mount(iframe);
      washi.setMode('annotate');
      const overlay = document.querySelector('.washi-overlay') as HTMLElement;
      expect(overlay.style.pointerEvents).toBe('auto');
    });

    it('throws for invalid mode', async () => {
      await washi.mount(iframe);
      expect(() => washi.setMode('invalid' as WashiMode)).toThrow();
    });

    it('throws in readOnly mode', async () => {
      await washi.mount(iframe, { readOnly: true });
      expect(() => washi.setMode('annotate')).toThrow('readOnly');
    });

    it('emits mode:changed event', async () => {
      await washi.mount(iframe);
      const handler = vi.fn();
      washi.on('mode:changed', handler);
      washi.setMode('annotate');
      expect(handler).toHaveBeenCalled();
    });
  });

  describe('addComment()', () => {
    it('adds comment and renders pin', async () => {
      await washi.mount(iframe);
      const comment = await washi.addComment(createNewComment());
      expect(comment.id).toBeTruthy();
      expect(comment.createdAt).toBeGreaterThan(0);
      expect(washi.getComments()).toHaveLength(1);
      expect(document.querySelector('.washi-pin')).toBeTruthy();
    });

    it('returns the completed comment with generated id and createdAt', async () => {
      await washi.mount(iframe);
      const input = createNewComment({ text: 'Hello', x: 30, y: 40 });
      const comment = await washi.addComment(input);
      expect(comment.id).toMatch(/^[0-9a-f-]{36}$/);
      expect(comment.text).toBe('Hello');
      expect(comment.x).toBe(30);
      expect(comment.y).toBe(40);
      expect(typeof comment.createdAt).toBe('number');
    });

    it('throws if not mounted', async () => {
      await expect(washi.addComment(createNewComment())).rejects.toThrow('not mounted');
    });

    it('validates coordinates', async () => {
      await washi.mount(iframe);
      await expect(washi.addComment(createNewComment({ x: 150 }))).rejects.toThrow('0-100');
      await expect(washi.addComment(createNewComment({ y: -5 }))).rejects.toThrow('0-100');
    });
  });

  describe('updateComment()', () => {
    it('updates comment', async () => {
      adapter.addComment(createTestComment({ id: 'update', text: 'Original' }));
      await washi.mount(iframe);
      await washi.updateComment('update', { text: 'Updated' });
      expect(washi.getComments()[0].text).toBe('Updated');
    });

    it('throws for non-existent comment', async () => {
      await washi.mount(iframe);
      await expect(washi.updateComment('fake', {})).rejects.toThrow();
    });
  });

  describe('deleteComment()', () => {
    it('removes comment and pin', async () => {
      adapter.addComment(createTestComment({ id: 'delete' }));
      await washi.mount(iframe);
      await washi.deleteComment('delete');
      expect(washi.getComments()).toHaveLength(0);
      expect(document.querySelector('.washi-pin')).toBeFalsy();
    });

    it('throws if not mounted', async () => {
      await expect(washi.deleteComment('any')).rejects.toThrow('not mounted');
    });
  });

  describe('on()', () => {
    it('returns unsubscribe function', async () => {
      await washi.mount(iframe);
      const handler = vi.fn();
      const unsub = washi.on('mode:changed', handler);
      washi.setMode('annotate');
      expect(handler).toHaveBeenCalledTimes(1);
      unsub();
      washi.setMode('view');
      expect(handler).toHaveBeenCalledTimes(1);
    });
  });
});
